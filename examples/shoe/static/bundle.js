(function(){var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var cached = require.cache[resolved];
    var res = cached? cached.exports : mod();
    return res;
};

require.paths = [];
require.modules = {};
require.cache = {};
require.extensions = [".js",".coffee",".json"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';
        
        if (require._core[x]) return x;
        var path = require.modules.path();
        cwd = path.resolve('/', cwd);
        var y = cwd || '/';
        
        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }
        
        var n = loadNodeModulesSync(x, y);
        if (n) return n;
        
        throw new Error("Cannot find module '" + x + "'");
        
        function loadAsFileSync (x) {
            x = path.normalize(x);
            if (require.modules[x]) {
                return x;
            }
            
            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }
        
        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = path.normalize(x + '/package.json');
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }
            
            return loadAsFileSync(x + '/index');
        }
        
        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }
            
            var m = loadAsFileSync(x);
            if (m) return m;
        }
        
        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');
            
            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }
            
            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);
    
    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key);
        return res;
    })(require.modules);
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

(function () {
    var process = {};
    var global = typeof window !== 'undefined' ? window : {};
    var definedProcess = false;
    
    require.define = function (filename, fn) {
        if (!definedProcess && require.modules.__browserify_process) {
            process = require.modules.__browserify_process();
            definedProcess = true;
        }
        
        var dirname = require._core[filename]
            ? ''
            : require.modules.path().dirname(filename)
        ;
        
        var require_ = function (file) {
            var requiredModule = require(file, dirname);
            var cached = require.cache[require.resolve(file, dirname)];

            if (cached && cached.parent === null) {
                cached.parent = module_;
            }

            return requiredModule;
        };
        require_.resolve = function (name) {
            return require.resolve(name, dirname);
        };
        require_.modules = require.modules;
        require_.define = require.define;
        require_.cache = require.cache;
        var module_ = {
            id : filename,
            filename: filename,
            exports : {},
            loaded : false,
            parent: null
        };
        
        require.modules[filename] = function () {
            require.cache[filename] = module_;
            fn.call(
                module_.exports,
                require_,
                module_,
                module_.exports,
                dirname,
                filename,
                process,
                global
            );
            module_.loaded = true;
            return module_.exports;
        };
    };
})();


require.define("path",Function(['require','module','exports','__dirname','__filename','process','global'],"function filter (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length; i >= 0; i--) {\n    var last = parts[i];\n    if (last == '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Regex to split a filename into [*, dir, basename, ext]\n// posix version\nvar splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\nvar resolvedPath = '',\n    resolvedAbsolute = false;\n\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n  var path = (i >= 0)\n      ? arguments[i]\n      : process.cwd();\n\n  // Skip empty and invalid entries\n  if (typeof path !== 'string' || !path) {\n    continue;\n  }\n\n  resolvedPath = path + '/' + resolvedPath;\n  resolvedAbsolute = path.charAt(0) === '/';\n}\n\n// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n\n// Normalize the path\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\nvar isAbsolute = path.charAt(0) === '/',\n    trailingSlash = path.slice(-1) === '/';\n\n// Normalize the path\npath = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n  \n  return (isAbsolute ? '/' : '') + path;\n};\n\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n};\n\n\nexports.dirname = function(path) {\n  var dir = splitPathRe.exec(path)[1] || '';\n  var isWindows = false;\n  if (!dir) {\n    // No dirname\n    return '.';\n  } else if (dir.length === 1 ||\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n    // It is just a slash or a drive letter with a slash\n    return dir;\n  } else {\n    // It is a full dirname, strip trailing slash\n    return dir.substring(0, dir.length - 1);\n  }\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPathRe.exec(path)[2] || '';\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPathRe.exec(path)[3] || '';\n};\n\n//@ sourceURL=path"
));

require.define("__browserify_process",Function(['require','module','exports','__dirname','__filename','process','global'],"var process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n        && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n        && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            if (ev.source === window && ev.data === 'browserify-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('browserify-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    if (name === 'evals') return (require)('vm')\n    else throw new Error('No such module. (Possibly not yet loaded)')\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    process.cwd = function () { return cwd };\n    process.chdir = function (dir) {\n        if (!path) path = require('path');\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n\n//@ sourceURL=__browserify_process"
));

require.define("/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/package.json"
));

require.define("/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var net = require('net')\n\nmodule.exports = require('./inject')(function (){ \n  var args = [].slice.call(arguments)\n  return net.connect.apply(null, args)\n})\n\n//@ sourceURL=/index.js"
));

require.define("net",Function(['require','module','exports','__dirname','__filename','process','global'],"// todo\n\n//@ sourceURL=net"
));

require.define("/inject.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var EventEmitter = require('events').EventEmitter\nvar backoff = require('backoff')\n\nmodule.exports =\nfunction (createConnection) {\n  return function (opts, onConnect) {\n    onConnect = 'function' == typeof opts ? opts : onConnect\n    opts = opts || {initialDelay: 1e3, maxDelay: 30e3}\n    if(!onConnect)\n      onConnect = opts.onConnect\n\n    var emitter = new EventEmitter()\n    emitter.connected = false\n    emitter.reconnect = true\n\n    if(onConnect)\n      //use \"connection\" to match core (net) api.\n      emitter.on('connection', onConnect)\n    \n    var backoffMethod = (backoff[opts.type] || backoff.fibonacci) (opts)\n\n    backoffMethod.on('backoff', function (n, d) {\n      emitter.emit('backoff', n, d)\n    })\n\n    var args\n    function attempt (n, delay) {\n      if(emitter.connected) return\n      if(!emitter.reconnect) return\n\n      emitter.emit('reconnect', n, delay)\n      var con = createConnection.apply(null, args)\n      emitter._connection = con\n\n      function onDisconnect (err) {\n        emitter.connected = false\n        con.removeListener('error', onDisconnect)\n        con.removeListener('close', onDisconnect)\n        con.removeListener('end'  , onDisconnect)\n\n        //hack to make http not crash.\n        //HTTP IS THE WORST PROTOCOL.\n        if(con.constructor.name == 'Request')\n          con.on('error', function () {})\n\n        //emit disconnect before checking reconnect, so user has a chance to decide not to.\n        emitter.emit('disconnect', err)\n\n        if(!emitter.reconnect) return\n        try { backoffMethod.backoff() } catch (_) { }\n      }\n\n      con\n        .on('error', onDisconnect)\n        .on('close', onDisconnect)\n        .on('end'  , onDisconnect)\n\n      if(opts.immediate || con.constructor.name == 'Request') {\n        emitter.connected = true\n        emitter.emit('connect', con)\n        emitter.emit('connection', con)\n        con.once('data', function () {\n          //this is the only way to know for sure that data is coming...\n          backoffMethod.reset()\n        })\n      } else {\n        con\n          .on('connect', function () {\n            backoffMethod.reset()\n            emitter.connected = true\n            con.removeListener('connect', onConnect)\n            emitter.emit('connect', con)\n            //also support net style 'connection' method.\n            emitter.emit('connection', con)\n          })\n      }\n    }\n\n    emitter.connect =\n    emitter.listen = function () {\n      this.reconnect = true\n      if(emitter.connected) return\n      backoffMethod.reset()\n      backoffMethod.on('ready', attempt)\n      args = args || [].slice.call(arguments)\n      attempt(0, 0)\n      return emitter\n    }\n\n    //force reconnection\n\n    emitter.disconnect = function () {\n      this.reconnect = false\n\n      if(emitter._connection)\n        emitter._connection.end()\n\n      emitter.emit('disconnect')\n      return emitter\n    }\n\n    var widget\n    emitter.widget = function () {\n      if(!widget)\n        widget = require('./widget')(emitter)\n      return widget\n    }\n\n    return emitter\n  }\n\n}\n\n//@ sourceURL=/inject.js"
));

require.define("events",Function(['require','module','exports','__dirname','__filename','process','global'],"if (!process.EventEmitter) process.EventEmitter = function () {};\n\nvar EventEmitter = exports.EventEmitter = process.EventEmitter;\nvar isArray = typeof Array.isArray === 'function'\n    ? Array.isArray\n    : function (xs) {\n        return Object.prototype.toString.call(xs) === '[object Array]'\n    }\n;\nfunction indexOf (xs, x) {\n    if (xs.indexOf) return xs.indexOf(x);\n    for (var i = 0; i < xs.length; i++) {\n        if (x === xs[i]) return i;\n    }\n    return -1;\n}\n\n// By default EventEmitters will print a warning if more than\n// 10 listeners are added to it. This is a useful default which\n// helps finding memory leaks.\n//\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nvar defaultMaxListeners = 10;\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!this._events) this._events = {};\n  this._events.maxListeners = n;\n};\n\n\nEventEmitter.prototype.emit = function(type) {\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events || !this._events.error ||\n        (isArray(this._events.error) && !this._events.error.length))\n    {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n      return false;\n    }\n  }\n\n  if (!this._events) return false;\n  var handler = this._events[type];\n  if (!handler) return false;\n\n  if (typeof handler == 'function') {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        var args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n    return true;\n\n  } else if (isArray(handler)) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var listeners = handler.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n    return true;\n\n  } else {\n    return false;\n  }\n};\n\n// EventEmitter is defined in src/node_events.cc\n// EventEmitter.prototype.emit() is also defined there.\nEventEmitter.prototype.addListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('addListener only takes instances of Function');\n  }\n\n  if (!this._events) this._events = {};\n\n  // To avoid recursion in the case that type == \"newListeners\"! Before\n  // adding it to the listeners, first emit \"newListeners\".\n  this.emit('newListener', type, listener);\n\n  if (!this._events[type]) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  } else if (isArray(this._events[type])) {\n\n    // Check for listener leak\n    if (!this._events[type].warned) {\n      var m;\n      if (this._events.maxListeners !== undefined) {\n        m = this._events.maxListeners;\n      } else {\n        m = defaultMaxListeners;\n      }\n\n      if (m && m > 0 && this._events[type].length > m) {\n        this._events[type].warned = true;\n        console.error('(node) warning: possible EventEmitter memory ' +\n                      'leak detected. %d listeners added. ' +\n                      'Use emitter.setMaxListeners() to increase limit.',\n                      this._events[type].length);\n        console.trace();\n      }\n    }\n\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  } else {\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  var self = this;\n  self.on(type, function g() {\n    self.removeListener(type, g);\n    listener.apply(this, arguments);\n  });\n\n  return this;\n};\n\nEventEmitter.prototype.removeListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('removeListener only takes instances of Function');\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (!this._events || !this._events[type]) return this;\n\n  var list = this._events[type];\n\n  if (isArray(list)) {\n    var i = indexOf(list, listener);\n    if (i < 0) return this;\n    list.splice(i, 1);\n    if (list.length == 0)\n      delete this._events[type];\n  } else if (this._events[type] === listener) {\n    delete this._events[type];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (type && this._events && this._events[type]) this._events[type] = null;\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  if (!this._events) this._events = {};\n  if (!this._events[type]) this._events[type] = [];\n  if (!isArray(this._events[type])) {\n    this._events[type] = [this._events[type]];\n  }\n  return this._events[type];\n};\n\n//@ sourceURL=events"
));

require.define("/node_modules/backoff/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/backoff/package.json"
));

require.define("/node_modules/backoff/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*\n * Copyright (c) 2012 Mathieu Turcotte\n * Licensed under the MIT license.\n */\n\nvar Backoff = require('./lib/backoff'),\n    FibonacciBackoffStrategy = require('./lib/strategy/fibonacci'),\n    ExponentialBackoffStrategy = require('./lib/strategy/exponential');\n\nmodule.exports.Backoff = Backoff;\nmodule.exports.FibonacciStrategy = FibonacciBackoffStrategy;\nmodule.exports.ExponentialStrategy = ExponentialBackoffStrategy;\n\n/**\n * Constructs a Fibonacci backoff.\n * @param options Fibonacci backoff strategy arguments.\n * @see FibonacciBackoffStrategy\n */\nmodule.exports.fibonacci = function(options) {\n    return new Backoff(new FibonacciBackoffStrategy(options));\n};\n\n/**\n * Constructs an exponential backoff.\n * @param options Exponential strategy arguments.\n * @see ExponentialBackoffStrategy\n */\nmodule.exports.exponential = function(options) {\n    return new Backoff(new ExponentialBackoffStrategy(options));\n};\n\n\n//@ sourceURL=/node_modules/backoff/index.js"
));

require.define("/node_modules/backoff/lib/backoff.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*\n * Copyright (c) 2012 Mathieu Turcotte\n * Licensed under the MIT license.\n */\n\nvar events = require('events'),\n    util = require('util');\n\n/**\n * Backoff driver.\n * @param backoffStrategy Backoff delay generator/strategy.\n * @constructor\n */\nfunction Backoff(backoffStrategy) {\n    events.EventEmitter.call(this);\n\n    this.backoffStrategy_ = backoffStrategy;\n    this.backoffNumber_ = 0;\n    this.backoffDelay_ = 0;\n    this.timeoutID_ = -1;\n\n    this.handlers = {\n        backoff: this.onBackoff_.bind(this)\n    };\n}\nutil.inherits(Backoff, events.EventEmitter);\n\n/**\n * Starts a backoff operation.\n */\nBackoff.prototype.backoff = function() {\n    if (this.timeoutID_ !== -1) {\n        throw new Error('Backoff in progress.');\n    }\n\n    this.backoffDelay_ = this.backoffStrategy_.next();\n    this.timeoutID_ = setTimeout(this.handlers.backoff, this.backoffDelay_);\n    this.emit('backoff', this.backoffNumber_, this.backoffDelay_);\n};\n\n/**\n * Backoff completion handler.\n * @private\n */\nBackoff.prototype.onBackoff_ = function() {\n    this.timeoutID_ = -1;\n    this.emit('ready', this.backoffNumber_++, this.backoffDelay_);\n};\n\n/**\n * Stops any backoff operation and resets the backoff\n * delay to its inital value.\n */\nBackoff.prototype.reset = function() {\n    this.backoffNumber_ = 0;\n    this.backoffStrategy_.reset();\n    clearTimeout(this.timeoutID_);\n    this.timeoutID_ = -1;\n};\n\nmodule.exports = Backoff;\n\n\n//@ sourceURL=/node_modules/backoff/lib/backoff.js"
));

require.define("util",Function(['require','module','exports','__dirname','__filename','process','global'],"var events = require('events');\n\nexports.isArray = isArray;\nexports.isDate = function(obj){return Object.prototype.toString.call(obj) === '[object Date]'};\nexports.isRegExp = function(obj){return Object.prototype.toString.call(obj) === '[object RegExp]'};\n\n\nexports.print = function () {};\nexports.puts = function () {};\nexports.debug = function() {};\n\nexports.inspect = function(obj, showHidden, depth, colors) {\n  var seen = [];\n\n  var stylize = function(str, styleType) {\n    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n    var styles =\n        { 'bold' : [1, 22],\n          'italic' : [3, 23],\n          'underline' : [4, 24],\n          'inverse' : [7, 27],\n          'white' : [37, 39],\n          'grey' : [90, 39],\n          'black' : [30, 39],\n          'blue' : [34, 39],\n          'cyan' : [36, 39],\n          'green' : [32, 39],\n          'magenta' : [35, 39],\n          'red' : [31, 39],\n          'yellow' : [33, 39] };\n\n    var style =\n        { 'special': 'cyan',\n          'number': 'blue',\n          'boolean': 'yellow',\n          'undefined': 'grey',\n          'null': 'bold',\n          'string': 'green',\n          'date': 'magenta',\n          // \"name\": intentionally not styling\n          'regexp': 'red' }[styleType];\n\n    if (style) {\n      return '\\033[' + styles[style][0] + 'm' + str +\n             '\\033[' + styles[style][1] + 'm';\n    } else {\n      return str;\n    }\n  };\n  if (! colors) {\n    stylize = function(str, styleType) { return str; };\n  }\n\n  function format(value, recurseTimes) {\n    // Provide a hook for user-specified inspect functions.\n    // Check that value is an object with an inspect function on it\n    if (value && typeof value.inspect === 'function' &&\n        // Filter out the util module, it's inspect function is special\n        value !== exports &&\n        // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n      return value.inspect(recurseTimes);\n    }\n\n    // Primitive types cannot have properties\n    switch (typeof value) {\n      case 'undefined':\n        return stylize('undefined', 'undefined');\n\n      case 'string':\n        var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                                 .replace(/'/g, \"\\\\'\")\n                                                 .replace(/\\\\\"/g, '\"') + '\\'';\n        return stylize(simple, 'string');\n\n      case 'number':\n        return stylize('' + value, 'number');\n\n      case 'boolean':\n        return stylize('' + value, 'boolean');\n    }\n    // For some reason typeof null is \"object\", so special case here.\n    if (value === null) {\n      return stylize('null', 'null');\n    }\n\n    // Look up the keys of the object.\n    var visible_keys = Object_keys(value);\n    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;\n\n    // Functions without properties can be shortcutted.\n    if (typeof value === 'function' && keys.length === 0) {\n      if (isRegExp(value)) {\n        return stylize('' + value, 'regexp');\n      } else {\n        var name = value.name ? ': ' + value.name : '';\n        return stylize('[Function' + name + ']', 'special');\n      }\n    }\n\n    // Dates without properties can be shortcutted\n    if (isDate(value) && keys.length === 0) {\n      return stylize(value.toUTCString(), 'date');\n    }\n\n    var base, type, braces;\n    // Determine the object type\n    if (isArray(value)) {\n      type = 'Array';\n      braces = ['[', ']'];\n    } else {\n      type = 'Object';\n      braces = ['{', '}'];\n    }\n\n    // Make functions say that they are functions\n    if (typeof value === 'function') {\n      var n = value.name ? ': ' + value.name : '';\n      base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';\n    } else {\n      base = '';\n    }\n\n    // Make dates with properties first say the date\n    if (isDate(value)) {\n      base = ' ' + value.toUTCString();\n    }\n\n    if (keys.length === 0) {\n      return braces[0] + base + braces[1];\n    }\n\n    if (recurseTimes < 0) {\n      if (isRegExp(value)) {\n        return stylize('' + value, 'regexp');\n      } else {\n        return stylize('[Object]', 'special');\n      }\n    }\n\n    seen.push(value);\n\n    var output = keys.map(function(key) {\n      var name, str;\n      if (value.__lookupGetter__) {\n        if (value.__lookupGetter__(key)) {\n          if (value.__lookupSetter__(key)) {\n            str = stylize('[Getter/Setter]', 'special');\n          } else {\n            str = stylize('[Getter]', 'special');\n          }\n        } else {\n          if (value.__lookupSetter__(key)) {\n            str = stylize('[Setter]', 'special');\n          }\n        }\n      }\n      if (visible_keys.indexOf(key) < 0) {\n        name = '[' + key + ']';\n      }\n      if (!str) {\n        if (seen.indexOf(value[key]) < 0) {\n          if (recurseTimes === null) {\n            str = format(value[key]);\n          } else {\n            str = format(value[key], recurseTimes - 1);\n          }\n          if (str.indexOf('\\n') > -1) {\n            if (isArray(value)) {\n              str = str.split('\\n').map(function(line) {\n                return '  ' + line;\n              }).join('\\n').substr(2);\n            } else {\n              str = '\\n' + str.split('\\n').map(function(line) {\n                return '   ' + line;\n              }).join('\\n');\n            }\n          }\n        } else {\n          str = stylize('[Circular]', 'special');\n        }\n      }\n      if (typeof name === 'undefined') {\n        if (type === 'Array' && key.match(/^\\d+$/)) {\n          return str;\n        }\n        name = JSON.stringify('' + key);\n        if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n          name = name.substr(1, name.length - 2);\n          name = stylize(name, 'name');\n        } else {\n          name = name.replace(/'/g, \"\\\\'\")\n                     .replace(/\\\\\"/g, '\"')\n                     .replace(/(^\"|\"$)/g, \"'\");\n          name = stylize(name, 'string');\n        }\n      }\n\n      return name + ': ' + str;\n    });\n\n    seen.pop();\n\n    var numLinesEst = 0;\n    var length = output.reduce(function(prev, cur) {\n      numLinesEst++;\n      if (cur.indexOf('\\n') >= 0) numLinesEst++;\n      return prev + cur.length + 1;\n    }, 0);\n\n    if (length > 50) {\n      output = braces[0] +\n               (base === '' ? '' : base + '\\n ') +\n               ' ' +\n               output.join(',\\n  ') +\n               ' ' +\n               braces[1];\n\n    } else {\n      output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n    }\n\n    return output;\n  }\n  return format(obj, (typeof depth === 'undefined' ? 2 : depth));\n};\n\n\nfunction isArray(ar) {\n  return ar instanceof Array ||\n         Array.isArray(ar) ||\n         (ar && ar !== Object.prototype && isArray(ar.__proto__));\n}\n\n\nfunction isRegExp(re) {\n  return re instanceof RegExp ||\n    (typeof re === 'object' && Object.prototype.toString.call(re) === '[object RegExp]');\n}\n\n\nfunction isDate(d) {\n  if (d instanceof Date) return true;\n  if (typeof d !== 'object') return false;\n  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);\n  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);\n  return JSON.stringify(proto) === JSON.stringify(properties);\n}\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\nexports.log = function (msg) {};\n\nexports.pump = null;\n\nvar Object_keys = Object.keys || function (obj) {\n    var res = [];\n    for (var key in obj) res.push(key);\n    return res;\n};\n\nvar Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {\n    var res = [];\n    for (var key in obj) {\n        if (Object.hasOwnProperty.call(obj, key)) res.push(key);\n    }\n    return res;\n};\n\nvar Object_create = Object.create || function (prototype, properties) {\n    // from es5-shim\n    var object;\n    if (prototype === null) {\n        object = { '__proto__' : null };\n    }\n    else {\n        if (typeof prototype !== 'object') {\n            throw new TypeError(\n                'typeof prototype[' + (typeof prototype) + '] != \\'object\\''\n            );\n        }\n        var Type = function () {};\n        Type.prototype = prototype;\n        object = new Type();\n        object.__proto__ = prototype;\n    }\n    if (typeof properties !== 'undefined' && Object.defineProperties) {\n        Object.defineProperties(object, properties);\n    }\n    return object;\n};\n\nexports.inherits = function(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object_create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n};\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (typeof f !== 'string') {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(exports.inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j': return JSON.stringify(args[i++]);\n      default:\n        return x;\n    }\n  });\n  for(var x = args[i]; i < len; x = args[++i]){\n    if (x === null || typeof x !== 'object') {\n      str += ' ' + x;\n    } else {\n      str += ' ' + exports.inspect(x);\n    }\n  }\n  return str;\n};\n\n//@ sourceURL=util"
));

require.define("/node_modules/backoff/lib/strategy/fibonacci.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*\n * Copyright (c) 2012 Mathieu Turcotte\n * Licensed under the MIT license.\n */\n\nvar util = require('util');\n\nvar BackoffStrategy = require('./strategy');\n\n/**\n * Fibonacci backoff strategy.\n * @extends BackoffStrategy\n */\nfunction FibonacciBackoffStrategy(options) {\n    BackoffStrategy.call(this, options);\n    this.backoffDelay_ = 0;\n    this.nextBackoffDelay_ = this.getInitialDelay();\n}\nutil.inherits(FibonacciBackoffStrategy, BackoffStrategy);\n\n/** @inheritDoc */\nFibonacciBackoffStrategy.prototype.next_ = function() {\n    var backoffDelay = Math.min(this.nextBackoffDelay_, this.getMaxDelay());\n    this.nextBackoffDelay_ += this.backoffDelay_;\n    this.backoffDelay_ = backoffDelay;\n    return backoffDelay;\n};\n\n/** @inheritDoc */\nFibonacciBackoffStrategy.prototype.reset_ = function() {\n    this.nextBackoffDelay_ = this.getInitialDelay();\n    this.backoffDelay_ = 0;\n};\n\nmodule.exports = FibonacciBackoffStrategy;\n\n\n//@ sourceURL=/node_modules/backoff/lib/strategy/fibonacci.js"
));

require.define("/node_modules/backoff/lib/strategy/strategy.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*\n * Copyright (c) 2012 Mathieu Turcotte\n * Licensed under the MIT license.\n */\n\nvar events = require('events'),\n    util = require('util');\n\nfunction isDef(value) {\n    return value !== undefined && value !== null;\n}\n\n/**\n * Abstract class defining the skeleton for all backoff strategies.\n * @param options Backoff strategy options.\n * @param options.randomisationFactor The randomisation factor, must be between\n * 0 and 1.\n * @param options.initialDelay The backoff initial delay, in milliseconds.\n * @param options.maxDelay The backoff maximal delay, in milliseconds.\n * @constructor\n */\nfunction BackoffStrategy(options) {\n    options = options || {};\n\n    if (isDef(options.initialDelay) && options.initialDelay < 1) {\n        throw new Error('The initial timeout must be greater than 0.');\n    } else if (isDef(options.maxDelay) && options.maxDelay < 1) {\n        throw new Error('The maximal timeout must be greater than 0.');\n    }\n\n    this.initialDelay_ = options.initialDelay || 100;\n    this.maxDelay_ = options.maxDelay || 10000;\n\n    if (this.maxDelay_ <= this.initialDelay_) {\n        throw new Error('The maximal backoff delay must be ' +\n                        'greater than the initial backoff delay.');\n    }\n\n    if (isDef(options.randomisationFactor) &&\n        (options.randomisationFactor < 0 || options.randomisationFactor > 1)) {\n        throw new Error('The randomisation factor must be between 0 and 1.');\n    }\n\n    this.randomisationFactor_ = options.randomisationFactor || 0;\n}\n\n/**\n * Retrieves the maximal backoff delay.\n * @return The maximal backoff delay.\n */\nBackoffStrategy.prototype.getMaxDelay = function() {\n    return this.maxDelay_;\n};\n\n/**\n * Retrieves the initial backoff delay.\n * @return The initial backoff delay.\n */\nBackoffStrategy.prototype.getInitialDelay = function() {\n    return this.initialDelay_;\n};\n\n/**\n * Template method that computes the next backoff delay.\n * @return The backoff delay, in milliseconds.\n */\nBackoffStrategy.prototype.next = function() {\n    var backoffDelay = this.next_();\n    var randomisationMultiple = 1 + Math.random() * this.randomisationFactor_;\n    var randomizedDelay = Math.round(backoffDelay * randomisationMultiple);\n    return randomizedDelay;\n};\n\n/**\n * Computes the next backoff delay.\n * @return The backoff delay, in milliseconds.\n */\nBackoffStrategy.prototype.next_ = function() {\n    throw new Error('BackoffStrategy.next_() unimplemented.');\n};\n\n/**\n * Template method that resets the backoff delay to its initial value.\n */\nBackoffStrategy.prototype.reset = function() {\n    this.reset_();\n};\n\n/**\n * Resets the backoff delay to its initial value.\n */\nBackoffStrategy.prototype.reset_ = function() {\n    throw new Error('BackoffStrategy.reset_() unimplemented.');\n};\n\nmodule.exports = BackoffStrategy;\n\n\n//@ sourceURL=/node_modules/backoff/lib/strategy/strategy.js"
));

require.define("/node_modules/backoff/lib/strategy/exponential.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*\n * Copyright (c) 2012 Mathieu Turcotte\n * Licensed under the MIT license.\n */\n\nvar util = require('util');\n\nvar BackoffStrategy = require('./strategy');\n\n/**\n * Exponential backoff strategy.\n * @extends BackoffStrategy\n */\nfunction ExponentialBackoffStrategy(options) {\n    BackoffStrategy.call(this, options);\n    this.backoffDelay_ = 0;\n    this.nextBackoffDelay_ = this.getInitialDelay();\n}\nutil.inherits(ExponentialBackoffStrategy, BackoffStrategy);\n\n/** @inheritDoc */\nExponentialBackoffStrategy.prototype.next_ = function() {\n    this.backoffDelay_ = Math.min(this.nextBackoffDelay_, this.getMaxDelay());\n    this.nextBackoffDelay_ = this.backoffDelay_ * 2;\n    return this.backoffDelay_;\n};\n\n/** @inheritDoc */\nExponentialBackoffStrategy.prototype.reset_ = function() {\n    this.backoffDelay_ = 0;\n    this.nextBackoffDelay_ = this.getInitialDelay();\n};\n\nmodule.exports = ExponentialBackoffStrategy;\n\n\n//@ sourceURL=/node_modules/backoff/lib/strategy/exponential.js"
));

require.define("/widget.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\nvar h = require('hyperscript')\nvar o = require('observable')\n//TODO make this just a small square that goes red/orange/green\n\nmodule.exports = function (emitter) {\n  var color = o(), count = o()\n  color('red'); count(' ')\n\n  var el = h('div', {\n    style: {\n      background: color,\n      width: '1em', height: '1em',\n      display: 'inline-block',\n      'text-align': 'center',\n      border: '1px solid black'\n    }, \n    onclick: function () {\n      emitter.connected \n        ? emitter.disconnect()\n        : emitter.connect()\n    }\n  },\n  count\n  )\n  var int\n  emitter.on('reconnect', function (n, d) {\n    var delay = Math.round(d / 1000) + 1\n    count(delay)\n    color('red')\n    clearInterval(int)\n    int = setInterval(function () {\n      count(delay > 0 ? --delay : 0)\n      color(delay ? 'red' :'orange')      \n    }, 1e3)\n  })\n  emitter.on('connect',   function () {\n    count(' ')\n    color('green')\n    clearInterval(int)\n  })\n  emitter.on('disconnect', function () {\n    //count('  ')\n    color('red')\n  })\n  return el\n}\n\n//@ sourceURL=/widget.js"
));

require.define("/node_modules/hyperscript/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/hyperscript/package.json"
));

require.define("/node_modules/hyperscript/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var split = require('browser-split')\nvar ClassList = require('class-list')\nvar DataSet = require('data-set')\nrequire('html-element')\n\nmodule.exports = h\n\nfunction h() {\n  var args = [].slice.call(arguments), e = null\n  function item (l) {\n    var r\n    function parseClass (string) {\n      var m = split(string, /([\\.#]?[a-zA-Z0-9_-]+)/)\n      forEach(m, function (v) {\n        var s = v.substring(1,v.length)\n        if(!v) return\n        if(!e)\n          e = document.createElement(v)\n        else if (v[0] === '.')\n          ClassList(e).add(s)\n        else if (v[0] === '#')\n          e.setAttribute('id', s)\n      })\n    }\n\n    if(l == null)\n      ;\n    else if('string' === typeof l) {\n      if(!e)\n        parseClass(l)\n      else\n        e.appendChild(r = document.createTextNode(l))\n    }\n    else if('number' === typeof l\n      || 'boolean' === typeof l\n      || l instanceof Date\n      || l instanceof RegExp ) {\n        e.appendChild(r = document.createTextNode(l.toString()))\n    }\n    //there might be a better way to handle this...\n    else if (isArray(l))\n      forEach(l, item)\n    else if(isNode(l))\n      e.appendChild(r = l)\n    else if(l instanceof Text)\n      e.appendChild(r = l)\n    else if ('object' === typeof l) {\n      for (var k in l) {\n        if('function' === typeof l[k]) {\n          if(/^on\\w+/.test(k)) {\n            e.addEventListener\n              ? e.addEventListener(k.substring(2), l[k], false)\n              : e.attachEvent(k, l[k])\n          } else {\n            e[k] = l[k]()\n            l[k](function (v) {\n              e[k] = v\n            })\n          }\n        }\n        else if(k === 'style') {\n          for (var s in l[k]) (function(s, v) {\n            if('function' === typeof v) {\n              e.style.setProperty(s, v())\n              v(function (val) {\n                e.style.setProperty(s, val)\n              })\n            } else\n              e.style.setProperty(s, l[k][s])\n          })(s, l[k][s])\n        } else if (k.substr(0, 5) === \"data-\") {\n          DataSet(e)[k.substr(5)] = l[k]\n        } else {\n          e[k] = l[k]\n        }\n      }\n    } else if ('function' === typeof l) {\n      //assume it's an observable!\n      var v = l()\n      e.appendChild(r = isNode(v) ? v : document.createTextNode(v))\n\n      l(function (v) {\n        if(isNode(v) && r.parentElement)\n          r.parentElement.replaceChild(v, r), r = v\n        else\n          r.textContent = v\n      })\n\n    }\n\n    return r\n  }\n  while(args.length)\n    item(args.shift())\n\n  return e\n}\n\nfunction isNode (el) {\n  return el && el.nodeName && el.nodeType\n}\n\nfunction isText (el) {\n  return el && el.nodeName === '#text' && el.nodeType == 3\n}\n\nfunction forEach (arr, fn) {\n  if (arr.forEach) return arr.forEach(fn)\n  for (var i = 0; i < arr.length; i++) fn(arr[i], i)\n}\n\nfunction isArray (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]'\n}\n\n//@ sourceURL=/node_modules/hyperscript/index.js"
));

require.define("/node_modules/hyperscript/node_modules/browser-split/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index.js\"}\n//@ sourceURL=/node_modules/hyperscript/node_modules/browser-split/package.json"
));

require.define("/node_modules/hyperscript/node_modules/browser-split/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*!\n * Cross-Browser Split 1.1.1\n * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>\n * Available under the MIT License\n * ECMAScript compliant, uniform cross-browser split method\n */\n\n/**\n * Splits a string into an array of strings using a regex or string separator. Matches of the\n * separator are not included in the result array. However, if `separator` is a regex that contains\n * capturing groups, backreferences are spliced into the result each time `separator` is matched.\n * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably\n * cross-browser.\n * @param {String} str String to split.\n * @param {RegExp|String} separator Regex or string to use for separating the string.\n * @param {Number} [limit] Maximum number of items to include in the result array.\n * @returns {Array} Array of substrings.\n * @example\n *\n * // Basic use\n * split('a b c d', ' ');\n * // -> ['a', 'b', 'c', 'd']\n *\n * // With limit\n * split('a b c d', ' ', 2);\n * // -> ['a', 'b']\n *\n * // Backreferences in result array\n * split('..word1 word2..', /([a-z]+)(\\d+)/i);\n * // -> ['..', 'word', '1', ' ', 'word', '2', '..']\n */\nmodule.exports = (function split(undef) {\n\n  var nativeSplit = String.prototype.split,\n    compliantExecNpcg = /()??/.exec(\"\")[1] === undef,\n    // NPCG: nonparticipating capturing group\n    self;\n\n  self = function(str, separator, limit) {\n    // If `separator` is not a regex, use `nativeSplit`\n    if (Object.prototype.toString.call(separator) !== \"[object RegExp]\") {\n      return nativeSplit.call(str, separator, limit);\n    }\n    var output = [],\n      flags = (separator.ignoreCase ? \"i\" : \"\") + (separator.multiline ? \"m\" : \"\") + (separator.extended ? \"x\" : \"\") + // Proposed for ES6\n      (separator.sticky ? \"y\" : \"\"),\n      // Firefox 3+\n      lastLastIndex = 0,\n      // Make `global` and avoid `lastIndex` issues by working with a copy\n      separator = new RegExp(separator.source, flags + \"g\"),\n      separator2, match, lastIndex, lastLength;\n    str += \"\"; // Type-convert\n    if (!compliantExecNpcg) {\n      // Doesn't need flags gy, but they don't hurt\n      separator2 = new RegExp(\"^\" + separator.source + \"$(?!\\\\s)\", flags);\n    }\n    /* Values for `limit`, per the spec:\n     * If undefined: 4294967295 // Math.pow(2, 32) - 1\n     * If 0, Infinity, or NaN: 0\n     * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;\n     * If negative number: 4294967296 - Math.floor(Math.abs(limit))\n     * If other: Type-convert, then use the above rules\n     */\n    limit = limit === undef ? -1 >>> 0 : // Math.pow(2, 32) - 1\n    limit >>> 0; // ToUint32(limit)\n    while (match = separator.exec(str)) {\n      // `separator.lastIndex` is not reliable cross-browser\n      lastIndex = match.index + match[0].length;\n      if (lastIndex > lastLastIndex) {\n        output.push(str.slice(lastLastIndex, match.index));\n        // Fix browsers whose `exec` methods don't consistently return `undefined` for\n        // nonparticipating capturing groups\n        if (!compliantExecNpcg && match.length > 1) {\n          match[0].replace(separator2, function() {\n            for (var i = 1; i < arguments.length - 2; i++) {\n              if (arguments[i] === undef) {\n                match[i] = undef;\n              }\n            }\n          });\n        }\n        if (match.length > 1 && match.index < str.length) {\n          Array.prototype.push.apply(output, match.slice(1));\n        }\n        lastLength = match[0].length;\n        lastLastIndex = lastIndex;\n        if (output.length >= limit) {\n          break;\n        }\n      }\n      if (separator.lastIndex === match.index) {\n        separator.lastIndex++; // Avoid an infinite loop\n      }\n    }\n    if (lastLastIndex === str.length) {\n      if (lastLength || !separator.test(\"\")) {\n        output.push(\"\");\n      }\n    } else {\n      output.push(str.slice(lastLastIndex));\n    }\n    return output.length > limit ? output.slice(0, limit) : output;\n  };\n\n  return self;\n})();\n\n//@ sourceURL=/node_modules/hyperscript/node_modules/browser-split/index.js"
));

require.define("/node_modules/hyperscript/node_modules/class-list/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/hyperscript/node_modules/class-list/package.json"
));

require.define("/node_modules/hyperscript/node_modules/class-list/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// contains, add, remove, toggle\nvar indexof = require('indexof')\n\nmodule.exports = ClassList\n\nfunction ClassList(elem) {\n    var cl = elem.classList\n\n    if (cl) {\n        return cl\n    }\n\n    var classList = {\n        add: add\n        , remove: remove\n        , contains: contains\n        , toggle: toggle\n        , toString: $toString\n        , length: 0\n        , item: item\n    }\n\n    return classList\n\n    function add(token) {\n        var list = getTokens()\n        if (indexof(list, token) > -1) {\n            return\n        }\n        list.push(token)\n        setTokens(list)\n    }\n\n    function remove(token) {\n        var list = getTokens()\n            , index = indexof(list, token)\n\n        if (index === -1) {\n            return\n        }\n\n        list.splice(index, 1)\n        setTokens(list)\n    }\n\n    function contains(token) {\n        return indexof(getTokens(), token) > -1\n    }\n\n    function toggle(token) {\n        if (contains(token)) {\n            remove(token)\n            return false\n        } else {\n            add(token)\n            return true\n        }\n    }\n\n    function $toString() {\n        return elem.className\n    }\n\n    function item(index) {\n        var tokens = getTokens()\n        return tokens[index] || null\n    }\n\n    function getTokens() {\n        var className = elem.className\n\n        return filter(className.split(\" \"), isTruthy)\n    }\n\n    function setTokens(list) {\n        var length = list.length\n\n        elem.className = list.join(\" \")\n        classList.length = length\n\n        for (var i = 0; i < list.length; i++) {\n            classList[i] = list[i]\n        }\n\n        delete list[length]\n    }\n}\n\nfunction filter (arr, fn) {\n    var ret = []\n    for (var i = 0; i < arr.length; i++) {\n        if (fn(arr[i])) ret.push(arr[i])\n    }\n    return ret\n}\n\nfunction isTruthy(value) {\n    return !!value\n}\n\n//@ sourceURL=/node_modules/hyperscript/node_modules/class-list/index.js"
));

require.define("/node_modules/hyperscript/node_modules/class-list/node_modules/indexof/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/hyperscript/node_modules/class-list/node_modules/indexof/package.json"
));

require.define("/node_modules/hyperscript/node_modules/class-list/node_modules/indexof/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\nvar indexOf = [].indexOf;\n\nmodule.exports = function(arr, obj){\n  if (indexOf) return arr.indexOf(obj);\n  for (var i = 0; i < arr.length; ++i) {\n    if (arr[i] === obj) return i;\n  }\n  return -1;\n};\n//@ sourceURL=/node_modules/hyperscript/node_modules/class-list/node_modules/indexof/index.js"
));

require.define("/node_modules/hyperscript/node_modules/data-set/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/hyperscript/node_modules/data-set/package.json"
));

require.define("/node_modules/hyperscript/node_modules/data-set/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Weakmap = require(\"weakmap\")\nvar Individual = require(\"individual\")\n\nvar datasetMap = Individual(\"__DATA_SET_WEAKMAP\", Weakmap())\n\nmodule.exports = DataSet\n\nfunction DataSet(elem) {\n    if (elem.dataset) {\n        return elem.dataset\n    }\n\n    var hash = datasetMap.get(elem)\n\n    if (!hash) {\n        hash = createHash(elem)\n        datasetMap.set(elem, hash)\n    }\n\n    return hash\n}\n\nfunction createHash(elem) {\n    var attributes = elem.attributes\n    var hash = {}\n\n    if (attributes === null || attributes === undefined) {\n        return hash\n    }\n\n    for (var i = 0; i < attributes.length; i++) {\n        var attr = attributes[i]\n\n        if (attr.name.substr(0,5) !== \"data-\") {\n            continue\n        }\n\n        hash[attr.name.substr(5)] = attr.value\n    }\n\n    return hash\n}\n\n//@ sourceURL=/node_modules/hyperscript/node_modules/data-set/index.js"
));

require.define("/node_modules/hyperscript/node_modules/data-set/node_modules/weakmap/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"weakmap.js\"}\n//@ sourceURL=/node_modules/hyperscript/node_modules/data-set/node_modules/weakmap/package.json"
));

require.define("/node_modules/hyperscript/node_modules/data-set/node_modules/weakmap/weakmap.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/* (The MIT License)\r\n *\r\n * Copyright (c) 2012 Brandon Benvie <http://bbenvie.com>\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and\r\n * associated documentation files (the 'Software'), to deal in the Software without restriction,\r\n * including without limitation the rights to use, copy, modify, merge, publish, distribute,\r\n * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included with all copies or\r\n * substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\r\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  CLAIM,\r\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\n// Original WeakMap implementation by Gozala @ https://gist.github.com/1269991\r\n// Updated and bugfixed by Raynos @ https://gist.github.com/1638059\r\n// Expanded by Benvie @ https://github.com/Benvie/harmony-collections\r\n\r\nvoid function(global, undefined_, undefined){\r\n  var getProps = Object.getOwnPropertyNames,\r\n      defProp  = Object.defineProperty,\r\n      toSource = Function.prototype.toString,\r\n      create   = Object.create,\r\n      hasOwn   = Object.prototype.hasOwnProperty,\r\n      funcName = /^\\n?function\\s?(\\w*)?_?\\(/;\r\n\r\n\r\n  function define(object, key, value){\r\n    if (typeof key === 'function') {\r\n      value = key;\r\n      key = nameOf(value).replace(/_$/, '');\r\n    }\r\n    return defProp(object, key, { configurable: true, writable: true, value: value });\r\n  }\r\n\r\n  function nameOf(func){\r\n    return typeof func !== 'function'\r\n          ? '' : 'name' in func\r\n          ? func.name : toSource.call(func).match(funcName)[1];\r\n  }\r\n\r\n  // ############\r\n  // ### Data ###\r\n  // ############\r\n\r\n  var Data = (function(){\r\n    var dataDesc = { value: { writable: true, value: undefined } },\r\n        datalock = 'return function(k){if(k===s)return l}',\r\n        uids     = create(null),\r\n\r\n        createUID = function(){\r\n          var key = Math.random().toString(36).slice(2);\r\n          return key in uids ? createUID() : uids[key] = key;\r\n        },\r\n\r\n        globalID = createUID(),\r\n\r\n        storage = function(obj){\r\n          if (hasOwn.call(obj, globalID))\r\n            return obj[globalID];\r\n\r\n          if (!Object.isExtensible(obj))\r\n            throw new TypeError(\"Object must be extensible\");\r\n\r\n          var store = create(null);\r\n          defProp(obj, globalID, { value: store });\r\n          return store;\r\n        };\r\n\r\n    // common per-object storage area made visible by patching getOwnPropertyNames'\r\n    define(Object, function getOwnPropertyNames(obj){\r\n      var props = getProps(obj);\r\n      if (hasOwn.call(obj, globalID))\r\n        props.splice(props.indexOf(globalID), 1);\r\n      return props;\r\n    });\r\n\r\n    function Data(){\r\n      var puid = createUID(),\r\n          secret = {};\r\n\r\n      this.unlock = function(obj){\r\n        var store = storage(obj);\r\n        if (hasOwn.call(store, puid))\r\n          return store[puid](secret);\r\n\r\n        var data = create(null, dataDesc);\r\n        defProp(store, puid, {\r\n          value: new Function('s', 'l', datalock)(secret, data)\r\n        });\r\n        return data;\r\n      }\r\n    }\r\n\r\n    define(Data.prototype, function get(o){ return this.unlock(o).value });\r\n    define(Data.prototype, function set(o, v){ this.unlock(o).value = v });\r\n\r\n    return Data;\r\n  }());\r\n\r\n\r\n  var WM = (function(data){\r\n    var validate = function(key){\r\n      if (key == null || typeof key !== 'object' && typeof key !== 'function')\r\n        throw new TypeError(\"Invalid WeakMap key\");\r\n    }\r\n\r\n    var wrap = function(collection, value){\r\n      var store = data.unlock(collection);\r\n      if (store.value)\r\n        throw new TypeError(\"Object is already a WeakMap\");\r\n      store.value = value;\r\n    }\r\n\r\n    var unwrap = function(collection){\r\n      var storage = data.unlock(collection).value;\r\n      if (!storage)\r\n        throw new TypeError(\"WeakMap is not generic\");\r\n      return storage;\r\n    }\r\n\r\n    var initialize = function(weakmap, iterable){\r\n      if (iterable !== null && typeof iterable === 'object' && typeof iterable.forEach === 'function') {\r\n        iterable.forEach(function(item, i){\r\n          if (item instanceof Array && item.length === 2)\r\n            set.call(weakmap, iterable[i][0], iterable[i][1]);\r\n        });\r\n      }\r\n    }\r\n\r\n\r\n    function WeakMap(iterable){\r\n      if (this === global || this == null || this === WeakMap.prototype)\r\n        return new WeakMap(iterable);\r\n\r\n      wrap(this, new Data);\r\n      initialize(this, iterable);\r\n    }\r\n\r\n    function get(key){\r\n      validate(key);\r\n      var value = unwrap(this).get(key);\r\n      return value === undefined_ ? undefined : value;\r\n    }\r\n\r\n    function set(key, value){\r\n      validate(key);\r\n      // store a token for explicit undefined so that \"has\" works correctly\r\n      unwrap(this).set(key, value === undefined ? undefined_ : value);\r\n    }\r\n\r\n    function has(key){\r\n      validate(key);\r\n      return unwrap(this).get(key) !== undefined;\r\n    }\r\n\r\n    function delete_(key){\r\n      validate(key);\r\n      var data = unwrap(this),\r\n          had = data.get(key) !== undefined;\r\n      data.set(key, undefined);\r\n      return had;\r\n    }\r\n\r\n    function toString(){\r\n      unwrap(this);\r\n      return '[object WeakMap]';\r\n    }\r\n\r\n    try {\r\n      var src = ('return '+delete_).replace('e_', '\\\\u0065'),\r\n          del = new Function('unwrap', 'validate', src)(unwrap, validate);\r\n    } catch (e) {\r\n      var del = delete_;\r\n    }\r\n\r\n    var src = (''+Object).split('Object');\r\n    var stringifier = function toString(){\r\n      return src[0] + nameOf(this) + src[1];\r\n    };\r\n\r\n    define(stringifier, stringifier);\r\n\r\n    var prep = { __proto__: [] } instanceof Array\r\n      ? function(f){ f.__proto__ = stringifier }\r\n      : function(f){ define(f, stringifier) };\r\n\r\n    prep(WeakMap);\r\n\r\n    [toString, get, set, has, del].forEach(function(method){\r\n      define(WeakMap.prototype, method);\r\n      prep(method);\r\n    });\r\n\r\n    return WeakMap;\r\n  }(new Data));\r\n\r\n  var defaultCreator = Object.create\r\n    ? function(){ return Object.create(null) }\r\n    : function(){ return {} };\r\n\r\n  function createStorage(creator){\r\n    var weakmap = new WM;\r\n    creator || (creator = defaultCreator);\r\n\r\n    function storage(object, value){\r\n      if (value || arguments.length === 2) {\r\n        weakmap.set(object, value);\r\n      } else {\r\n        value = weakmap.get(object);\r\n        if (value === undefined) {\r\n          value = creator(object);\r\n          weakmap.set(object, value);\r\n        }\r\n      }\r\n      return value;\r\n    }\r\n\r\n    return storage;\r\n  }\r\n\r\n\r\n  if (typeof module !== 'undefined') {\r\n    module.exports = WM;\r\n  } else if (typeof exports !== 'undefined') {\r\n    exports.WeakMap = WM;\r\n  } else if (!('WeakMap' in global)) {\r\n    global.WeakMap = WM;\r\n  }\r\n\r\n  WM.createStorage = createStorage;\r\n  if (global.WeakMap)\r\n    global.WeakMap.createStorage = createStorage;\r\n}((0, eval)('this'));\r\n\n//@ sourceURL=/node_modules/hyperscript/node_modules/data-set/node_modules/weakmap/weakmap.js"
));

require.define("/node_modules/hyperscript/node_modules/data-set/node_modules/individual/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/hyperscript/node_modules/data-set/node_modules/individual/package.json"
));

require.define("/node_modules/hyperscript/node_modules/data-set/node_modules/individual/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var root = require(\"global\")\n\nmodule.exports = Individual\n\nfunction Individual(key, value) {\n    if (root[key]) {\n        return root[key]\n    }\n\n    Object.defineProperty(root, key, {\n        value: value\n        , configurable: true\n    })\n\n    return value\n}\n\n//@ sourceURL=/node_modules/hyperscript/node_modules/data-set/node_modules/individual/index.js"
));

require.define("/node_modules/hyperscript/node_modules/data-set/node_modules/individual/node_modules/global/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/hyperscript/node_modules/data-set/node_modules/individual/node_modules/global/package.json"
));

require.define("/node_modules/hyperscript/node_modules/data-set/node_modules/individual/node_modules/global/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*global window, global*/\nif (typeof global !== \"undefined\") {\n    module.exports = global\n} else if (typeof window !== \"undefined\") {\n    module.exports = window\n}\n\n//@ sourceURL=/node_modules/hyperscript/node_modules/data-set/node_modules/individual/node_modules/global/index.js"
));

require.define("/node_modules/hyperscript/node_modules/html-element/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index.js\"}\n//@ sourceURL=/node_modules/hyperscript/node_modules/html-element/package.json"
));

require.define("/node_modules/hyperscript/node_modules/html-element/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"global.Document = Document\nglobal.Node     = Node\nglobal.Element  = Element\nglobal.Text     = Text\nglobal.document = new Document()\n\nfunction Document() {}\n\nDocument.prototype.createTextNode = function(v) {\n    var n = new Text();\n    n.textContent = v;\n    n.nodeName = '#text'\n    n.nodeType = 3\n    return n;\n}\n\nDocument.prototype.createElement = function(nodeName) {\n    var el = new Element();\n    el.nodeName = nodeName;\n    return el;\n}\n\nfunction Node () {}\n\nText.prototype = new Node()\n\nElement.prototype = new Node()\n\nfunction Style (el) {\n  this.el = el;\n  this.styles = [];\n}\n\nStyle.prototype.setProperty = function (n,v) {\n  var attr = this.el.getAttribute('style');\n\n  !attr && this.el.setAttribute('style', '');\n  this.el._setProperty(this.styles, {name: n, value:v});\n}\n\nStyle.prototype.getProperty = function(n) {    \n    return this.el._getProperty(this.styles, n);\n}\n\nfunction classList(el) {  \n  this.el = el;\n}\n\nclassList.prototype.add = function(cls) {    \n  !this.el.getAttribute('class') && this.el.setAttribute('class','');  \n  var v = this.el.getAttribute('class').value;\n  this.el.setAttribute('class',v.length ? v+cls+' ' : v+cls);\n}\n\nfunction Attribute(name, value){  \n  if (name) {\n    this.name = name;\n    this.value = value ? value : '';\n  }  \n}\n\n\nfunction Element() {\n    var self = this;\n\n    this.style = new Style(this)\n    this.classList = new classList(this);\n    this.childNodes = [];\n    this.attributes = [];\n    this.className = '';\n\n    this._setProperty = function(arr, obj, key, val) {\n      var p = self._getProperty(arr, key);      \n      if (p) {\n        p.value = val;\n        return;\n      }\n      arr.push('function' === typeof obj ? new obj(key.toLowerCase(),val) : obj);\n    }\n\n    this._getProperty = function(arr, key) {\n      if (!key) return;\n      key = key.toLowerCase();\n      for (var i=0;i<arr.length;i++) {\n        if (key == arr[i].name) return arr[i];\n      }\n    }\n}\n\nElement.prototype.nodeType = 1;\n\nElement.prototype.appendChild = function(child) {\n    child.parentElement = this;\n    this.childNodes.push(child);\n}\n\nElement.prototype.setAttribute = function (n, v) {\n    this._setProperty(this.attributes, Attribute, n, v);\n}\n\nElement.prototype.getAttribute = function(n) {\n    return this._getProperty(this.attributes, n);\n}\n\nElement.prototype.replaceChild = function(newChild, oldChild) {\n    var self = this;\n    this.childNodes.forEach(function(child, index){\n        if (child === oldChild)\n        self.childNodes[index] = newChild;\n    });\n}\n\nElement.prototype.removeChild = function(rChild) {\n    var self = this;\n    this.childNodes.forEach(function(child, index){\n      if (child === rChild) delete self.childNodes[index];\n    })\n}\n\nElement.prototype.insertBefore = function(newChild, existingChild) {\n    var self = this;\n    this.childNodes.forEach(function(child, index){      \n      if (child === existingChild) {\n        index === 0 ?  self.childNodes.unshift(newChild)\n                    :  self.childNodes.splice(index, 0, newChild);\n      }  \n    })\n}\n\nElement.prototype.__defineGetter__('innerHTML', function () {\n  var s = ''\n  this.childNodes.forEach(function (e) {\n    s += (e.outerHTML || e.textContent)\n  })\n  return s\n})\n\nElement.prototype.__defineSetter__('innerHTML', function (v) {\n  //only handle this simple case that doesn't need parsing\n  //this case is useful... parsing is hard and will need added deps!\n  if(v == '')\n    this.childNodes.length = 0\n})\n\n\nElement.prototype.__defineGetter__('outerHTML', function () {\n  var a = [],  self = this;\n  \n  function _stringify(arr) {\n    var attr = [], value;        \n    arr.forEach(function(a){\n      value = ('style' != a.name) ? a.value : _stylify(self.style.styles);\n      attr.push(a.name+'='+'\\\"'+value+'\\\"');\n    })\n    return attr.length ? ' '+attr.join(\" \") : '';\n  }    \n\n  function _stylify(styles) {      \n    var stylified = '';\n    styles.forEach(function(s){\n      stylified+=s.name+':'+s.value+';';\n    })\n    return stylified;\n  }\n\n   function _propertify() {\n    var props = [];\n    for (var key in self) {            \n      _isProperty(key) && props.push({name: key, value:self[key]});\n    }    \n    // special className case, if className property is define while 'class' attribute is not then\n    // include class attribute in output\n    self.className.length && !self.getAttribute('class') && props.push({name:'class', value: self.className})   \n    return props ? _stringify(props) : '';\n  }\n\n  function _isProperty(key) {          \n      var types = ['string','boolean','number']      \n      for (var i=0; i<=types.length;i++) {        \n        if (self.hasOwnProperty(key) && \n            types[i] === typeof self[key] &&\n            key !== 'nodeName' &&\n            key !== 'nodeType' &&\n            key !== 'className'\n            ) return true;\n      }      \n  }\n\n  a.push('<'+this.nodeName + _propertify() + _stringify(this.attributes)+'>')\n\n  a.push(this.innerHTML)\n\n  a.push('</'+this.nodeName+'>')\n\n  return a.join('\\n')\n})\n\nElement.prototype.__defineGetter__('textContent', function () {\n  var s = ''\n  this.childNodes.forEach(function (e) {\n    s += e.textContent\n  })\n  return s\n})\n\nElement.prototype.addEventListener = function(t, l) {}\n\nfunction escapeHTML(s) {\n  return String(s)\n      .replace(/&/g, '&amp;')\n      .replace(/\"/g, '&#x27;')\n      .replace(/'/g, '&quot;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;');\n  }\n\nfunction Text(){}\n\nText.prototype.nodeType = 3;\n\nText.prototype.nodeName = '#text';\n\nText.prototype.__defineGetter__('textContent', function() {\n  return escapeHTML(this.value || '');\n})\n\nText.prototype.__defineSetter__('textContent', function(v) {\n  this.value = v\n})\n\n\n//@ sourceURL=/node_modules/hyperscript/node_modules/html-element/index.js"
));

require.define("/node_modules/observable/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/observable/package.json"
));

require.define("/node_modules/observable/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],";(function () {\n\n// bind a to b -- One Way Binding\nfunction bind1(a, b) {\n  a(b()); b(a)\n}\n//bind a to b and b to a -- Two Way Binding\nfunction bind2(a, b) {\n  b(a()); a(b); b(a);\n}\n\n//---util-funtions------\n\n//check if this call is a get.\nfunction isGet(val) {\n  return undefined === val\n}\n\n//check if this call is a set, else, it's a listen\nfunction isSet(val) {\n  return 'function' !== typeof val\n}\n\n//trigger all listeners\nfunction all(ary, val) {\n  for(var k in ary)\n    ary[k](val)\n}\n\n//remove a listener\nfunction remove(ary, item) {\n  delete ary[ary.indexOf(item)]\n}\n\n//register a listener\nfunction on(emitter, event, listener) {\n  (emitter.on || emitter.addEventListener)\n    .call(emitter, event, listener, false)\n}\n\nfunction off(emitter, event, listener) {\n  (emitter.removeListener || emitter.removeEventListener || emitter.off)\n    .call(emitter, event, listener, false)\n}\n\n//An observable that stores a value.\n\nfunction value () {\n  var _val, listeners = []\n  return function (val) {\n    return (\n      isGet(val) ? _val\n    : isSet(val) ? all(listeners, _val = val)\n    : (listeners.push(val), function () {\n        remove(listeners, val)\n      })\n  )}}\n  //^ if written in this style, always ends )}}\n\n/*\n##property\nobserve a property of an object, works with scuttlebutt.\ncould change this to work with backbone Model - but it would become ugly.\n*/\n\nfunction property (model, key) {\n  return function (val) {\n    return (\n      isGet(val) ? model.get(key) :\n      isSet(val) ? model.set(key, val) :\n      (on(model, 'change:'+key, val), function () {\n        off(model, 'change:'+key, val)\n      })\n    )}}\n\n/*\nnote the use of the elvis operator `?:` in chained else-if formation,\nand also the comma operator `,` which evaluates each part and then\nreturns the last value.\n\nonly 8 lines! that isn't much for what this baby can do!\n*/\n\nfunction transform (observable, down, up) {\n  if('function' !== typeof observable)\n    throw new Error('transform expects an observable')\n  return function (val) {\n    return (\n      isGet(val) ? down(observable())\n    : isSet(val) ? observable((up || down)(val))\n    : observable(function (_val) { val(down(_val)) })\n    )}}\n\nfunction not(observable) {\n  return transform(observable, function (v) { return !v })\n}\n\nfunction listen (element, event, attr, listener) {\n  function onEvent () {\n    listener('function' === typeof attr ? attr() : element[attr])\n  }\n  on(element, event, onEvent)\n  return function () {\n    off(element, event, onEvent)\n  }\n}\n\n//observe html element - aliased as `input`\nfunction attribute(element, attr, event) {\n  attr = attr || 'value'; event = event || 'input'\n  return function (val) {\n    return (\n      isGet(val) ? element[attr]\n    : isSet(val) ? element[attr] = val\n    : listen(element, event, attr, val)\n    )}\n}\n\n// observe a select element\nfunction select(element) {\n  function _attr () {\n      return element[element.selectedIndex].value;\n  }\n  function _set(val) {\n    for(var i=0; i < element.options.length; i++) {\n      if(element.options[i].value == val) element.selectedIndex = i;\n    }\n  }\n  return function (val) {\n    return (\n      isGet(val) ? element.options[element.selectedIndex].value\n    : isSet(val) ? _set(val)\n    : listen(element, 'change', _attr, val)\n    )}\n}\n\n//toggle based on an event, like mouseover, mouseout\nfunction toggle (el, up, down) {\n  var i = false\n  return function (val) {\n    function onUp() {\n      i || val(i = true)\n    }\n    function onDown () {\n      i && val(i = false)\n    }\n    return (\n      isGet(val) ? i\n    : isSet(val) ? undefined //read only\n    : (on(el, up, onUp), on(el, down || up, onDown), function () {\n      off(el, up, onUp); off(el, down || up, onDown)\n    })\n  )}}\n\nfunction error (message) {\n  throw new Error(message)\n}\n\nfunction compute (observables, compute) {\n  function getAll() {\n    return compute.apply(null, observables.map(function (e) {return e()}))\n  }\n  return function (val) {\n    return (\n      isGet(val) ? getAll()\n    : isSet(val) ? error('read-only')\n    : observables.forEach(function (obs) {\n        obs(function () { val(getAll()) })\n      })\n    )}}\n\nfunction boolean (observable, truthy, falsey) {\n  return transform(observable, function (val) {\n      return val ? truthy : falsey\n    }, function (val) {\n      return val == truthy ? true : false\n    })\n  }\n\nvar exports = value\nexports.bind1     = bind1\nexports.bind2     = bind2\nexports.value     = value\nexports.not       = not\nexports.property  = property\nexports.input     =\nexports.attribute = attribute\nexports.select    = select\nexports.compute   = compute\nexports.transform = transform\nexports.boolean   = boolean\nexports.toggle    = toggle\nexports.hover     = function (e) { return toggle(e, 'mouseover', 'mouseout')}\nexports.focus     = function (e) { return toggle(e, 'focus', 'blur')}\n\nif('object' === typeof module) module.exports = exports\nelse                           this.observable = exports\n})()\n\n//@ sourceURL=/node_modules/observable/index.js"
));

require.define("/examples/shoe/node_modules/domready/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./ready.js\"}\n//@ sourceURL=/examples/shoe/node_modules/domready/package.json"
));

require.define("/examples/shoe/node_modules/domready/ready.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*!\n  * domready (c) Dustin Diaz 2012 - License MIT\n  */\n!function (name, definition) {\n  if (typeof module != 'undefined') module.exports = definition()\n  else if (typeof define == 'function' && typeof define.amd == 'object') define(definition)\n  else this[name] = definition()\n}('domready', function (ready) {\n\n  var fns = [], fn, f = false\n    , doc = document\n    , testEl = doc.documentElement\n    , hack = testEl.doScroll\n    , domContentLoaded = 'DOMContentLoaded'\n    , addEventListener = 'addEventListener'\n    , onreadystatechange = 'onreadystatechange'\n    , readyState = 'readyState'\n    , loadedRgx = hack ? /^loaded|^c/ : /^loaded|c/\n    , loaded = loadedRgx.test(doc[readyState])\n\n  function flush(f) {\n    loaded = 1\n    while (f = fns.shift()) f()\n  }\n\n  doc[addEventListener] && doc[addEventListener](domContentLoaded, fn = function () {\n    doc.removeEventListener(domContentLoaded, fn, f)\n    flush()\n  }, f)\n\n\n  hack && doc.attachEvent(onreadystatechange, fn = function () {\n    if (/^c/.test(doc[readyState])) {\n      doc.detachEvent(onreadystatechange, fn)\n      flush()\n    }\n  })\n\n  return (ready = hack ?\n    function (fn) {\n      self != top ?\n        loaded ? fn() : fns.push(fn) :\n        function () {\n          try {\n            testEl.doScroll('left')\n          } catch (e) {\n            return setTimeout(function() { ready(fn) }, 50)\n          }\n          fn()\n        }()\n    } :\n    function (fn) {\n      loaded ? fn() : fns.push(fn)\n    })\n})\n//@ sourceURL=/examples/shoe/node_modules/domready/ready.js"
));

require.define("/examples/shoe/node_modules/event-stream/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/examples/shoe/node_modules/event-stream/package.json"
));

require.define("/examples/shoe/node_modules/event-stream/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"//filter will reemit the data if cb(err,pass) pass is truthy\n// reduce is more tricky\n// maybe we want to group the reductions or emit progress updates occasionally\n// the most basic reduce just emits one 'data' event after it has recieved 'end'\n\n\nvar Stream = require('stream').Stream\n  , es = exports\n\nes.Stream = Stream //re-export Stream from core\n\n// through\n//\n// a stream that does nothing but re-emit the input.\n// useful for aggregating a series of changing but not ending streams into one stream)\n\nes.through = function (write, end) {\n  write = write || function (data) { this.emit('data', data) }\n  end = (\n    'sync'== end || !end\n  //use sync end. (default)\n  ? function () { this.emit('end') }\n  : 'async' == end || end === true \n  //use async end.\n  //must eventually call drain if paused.\n  //else will not end.\n  ? function () {\n      if(!this.paused)\n        return this.emit('end')\n     var self = this\n     this.once('drain', function () {\n        self.emit('end')\n      })\n    }\n  //use custom end function\n  : end \n  )\n  var ended = false\n  var stream = new Stream()\n  stream.readable = stream.writable = true\n  \n  stream.write = function (data) {\n    write.call(this, data)\n    return !stream.paused\n  }\n\n  stream.on('end', function () {\n    stream.readable = false\n    if(!stream.writable)\n      stream.destroy()\n  })\n\n  stream.end = function (data) {\n    if(ended) return\n    ended = true\n    if(arguments.length) stream.write(data)\n    this.writable = false\n    end.call(this)\n    if(!this.readable)\n      this.destroy()\n  }\n  /*\n    destroy is called on a writable stream when the upstream closes.\n    it's basically END but something has gone wrong.\n    I'm gonna emit 'close' and change then otherwise act as 'end'\n  */\n  stream.destroy = function () {\n    ended = true\n    stream.writable = stream.readable = false\n    stream.emit('close')\n  }\n  stream.pause = function () {\n    stream.paused = true\n  }\n  stream.resume = function () {\n    if(stream.paused)\n      stream.emit('drain')\n    stream.paused = false\n  }\n  return stream\n}\n\n// buffered\n//\n// same as a through stream, but won't emit a chunk until the next tick.\n// does not support any pausing. intended for testing purposes.\n\n// XXX: rewrite this. this is crap. but do I actually use it? maybe just throw it away?\n// okay, it's used in snob. so... throw this out and let snob use a legacy version. (fix later/never)\n\n\n// merge / concat\n//\n// combine multiple streams into a single stream.\n// will emit end only once\nes.concat = //actually this should be called concat\nes.merge = function (/*streams...*/) {\n  var toMerge = [].slice.call(arguments)\n  var stream = new Stream()\n  var endCount = 0\n  stream.writable = stream.readable = true\n\n  toMerge.forEach(function (e) {\n    e.pipe(stream, {end: false})\n    var ended = false\n    e.on('end', function () {\n      if(ended) return\n      ended = true\n      endCount ++\n      if(endCount == toMerge.length)\n        stream.emit('end') \n    })\n  })\n  stream.write = function (data) {\n    this.emit('data', data)\n  }\n\n  return stream\n}\n\n\n// writable stream, collects all events into an array \n// and calls back when 'end' occurs\n// mainly I'm using this to test the other functions\n\nes.writeArray = function (done) {\n  if ('function' !== typeof done)\n    throw new Error('function writeArray (done): done must be function')\n\n  var a = new Stream ()\n    , array = []\n  a.write = function (l) {\n    array.push(l)\n  }\n  a.end = function () {\n    done(null, array)\n  }\n  a.writable = true\n  a.readable = false\n  return a\n}\n\n//return a Stream that reads the properties of an object\n//respecting pause() and resume()\n\nes.readArray = function (array) {\n  var stream = new Stream()\n    , i = 0\n    , paused = false\n \n  stream.readable = true  \n  stream.writable = false\n \n  if(!Array.isArray(array))\n    throw new Error('event-stream.read expects an array')\n  \n  stream.resume = function () {\n    paused = false\n    var l = array.length\n    while(i < l && !paused) {\n      stream.emit('data', array[i++])\n    }\n    if(i == l)\n      stream.emit('end'), stream.readable = false\n  }\n  process.nextTick(stream.resume)\n  stream.pause = function () {\n     paused = true\n  }\n  return stream\n}\n\n//\n// readable (asyncFunction)\n// return a stream that calls an async function while the stream is not paused.\n//\n// the function must take: (count, callback) {...\n//\nes.readable = function (func, continueOnError) {\n  var stream = new Stream()\n    , i = 0\n    , paused = false\n    , ended = false\n    , reading = false\n\n  stream.readable = true  \n  stream.writable = false\n \n  if('function' !== typeof func)\n    throw new Error('event-stream.readable expects async function')\n  \n  stream.on('end', function () { ended = true })\n  \n  function get (err, data) {\n    \n    if(err) {\n      stream.emit('error', err)\n      if(!continueOnError) stream.emit('end')\n    } else if (arguments.length > 1)\n      stream.emit('data', data)\n\n    process.nextTick(function () {\n      if(ended || paused || reading) return\n      try {\n        reading = true\n        func.call(stream, i++, function () {\n          reading = false\n          get.apply(null, arguments)\n        })\n      } catch (err) {\n        stream.emit('error', err)    \n      }\n    })\n  \n  }\n  stream.resume = function () {\n    paused = false\n    get()\n  }\n  process.nextTick(get)\n  stream.pause = function () {\n     paused = true\n  }\n  stream.destroy = function () {\n    stream.emit('close')\n    stream.emit('end')\n    ended = true\n  }\n  return stream\n}\n\n\n//create an event stream and apply function to each .write\n//emitting each response as data\n//unless it's an empty callback\n\nes.map = function (mapper) {\n  var stream = new Stream()\n    , inputs = 0\n    , outputs = 0\n    , ended = false\n    , paused = false\n    , destroyed = false\n\n  stream.writable = true\n  stream.readable = true\n   \n  stream.write = function () {\n    if(ended) throw new Error('map stream is not writable')\n    inputs ++\n    var args = [].slice.call(arguments)\n      , r\n      , inNext = false \n    //pipe only allows one argument. so, do not \n    function next (err) {\n      if(destroyed) return\n      inNext = true\n      outputs ++\n      var args = [].slice.call(arguments)\n      if(err) {\n        args.unshift('error')\n        return inNext = false, stream.emit.apply(stream, args)\n      }\n      args.shift() //drop err\n      if (args.length){\n        args.unshift('data')\n        r = stream.emit.apply(stream, args)\n      }\n      if(inputs == outputs) {\n        if(paused) paused = false, stream.emit('drain') //written all the incoming events\n        if(ended)\n          stream.end()\n      }\n      inNext = false\n    }\n    args.push(next)\n    \n    try {\n      //catch sync errors and handle them like async errors\n      var written = mapper.apply(null, args)\n      if(written === false) paused = true\n      return written\n    } catch (err) {\n      //if the callback has been called syncronously, and the error\n      //has occured in an listener, throw it again.\n      if(inNext)\n        throw err\n      next(err)\n      return true\n    }\n  }\n\n  stream.end = function () {\n    var args = [].slice.call(arguments)\n    //if end was called with args, write it, \n    ended = true //write will emit 'end' if ended is true\n    if(args.length)\n      return stream.write.apply(emitter, args)\n    else if (inputs == outputs) //wait for processing\n      stream.emit('end')\n  }\n\n  stream.destroy = function () {\n    ended = destroyed = true\n    stream.writable = stream.readable = paused = false\n  }\n\n  return stream\n}\n\n\n//\n// map sync\n//\n\nes.mapSync = function (sync) { \n  return es.through(function write(data) {\n    var mappedData = sync(data)\n    if (typeof mappedData !== 'undefined')\n      this.emit('data', mappedData)\n  })\n}\n\n//\n// log just print out what is coming through the stream, for debugging\n//\n\nes.log = function (name) {\n  return es.through(function (data) {\n    var args = [].slice.call(arguments)\n    if(name) console.error(name, data)\n    else     console.error(data)\n    this.emit('data', data)\n  })\n}\n\n//\n// combine multiple streams together so that they act as a single stream\n//\n\nes.pipe = es.connect = function () {\n\n  var streams = [].slice.call(arguments)\n    , first = streams[0]\n    , last = streams[streams.length - 1]\n    , thepipe = es.duplex(first, last)\n\n  if(streams.length == 1)\n    return streams[0]\n  else if (!streams.length)\n    throw new Error('connect called with empty args')\n\n  //pipe all the streams together\n\n  function recurse (streams) {\n    if(streams.length < 2)\n      return\n    streams[0].pipe(streams[1])\n    recurse(streams.slice(1))  \n  }\n  \n  recurse(streams)\n \n  function onerror () {\n    var args = [].slice.call(arguments)\n    args.unshift('error')\n    thepipe.emit.apply(thepipe, args)\n  }\n  \n  streams.forEach(function (stream) {\n    stream.on('error', onerror)\n  })\n\n  return thepipe\n}\n\n//\n// child -- pipe through a child process\n//\n\nes.child = function (child) {\n\n  return es.duplex(child.stdin, child.stdout)\n\n}\n\n//\n// duplex -- pipe into one stream and out another\n//\n\nes.duplex = function (writer, reader) {\n  var thepipe = new Stream()\n\n  thepipe.__defineGetter__('writable', function () { return writer.writable })\n  thepipe.__defineGetter__('readable', function () { return reader.readable })\n\n  ;['write', 'end', 'close'].forEach(function (func) {\n    thepipe[func] = function () {\n      return writer[func].apply(writer, arguments)\n    }\n  })\n\n  ;['resume', 'pause'].forEach(function (func) {\n    thepipe[func] = function () { \n      thepipe.emit(func)\n      if(reader[func])\n        return reader[func].apply(reader, arguments)\n      else\n        reader.emit(func)\n    }\n  })\n\n  ;['data', 'close'].forEach(function (event) {\n    reader.on(event, function () {\n      var args = [].slice.call(arguments)\n      args.unshift(event)\n      thepipe.emit.apply(thepipe, args)\n    })\n  })\n  //only emit end once\n  var ended = false\n  reader.on('end', function () {\n    if(ended) return\n    ended = true\n    var args = [].slice.call(arguments)\n    args.unshift('end')\n    thepipe.emit.apply(thepipe, args)\n  })\n\n  thepipe.destroy = function () {\n    if(reader.destroy)\n      reader.destroy()\n    if(writer.destroy)\n      writer.destroy()\n  }\n\n  return thepipe\n}\n\nes.split = function (matcher) {\n  var soFar = ''\n  if (!matcher)\n    matcher = '\\n'\n\n  return es.through(function (buffer) { \n    var stream = this\n      , pieces = (soFar + buffer).split(matcher)\n    soFar = pieces.pop()\n\n    pieces.forEach(function (piece) {\n      stream.emit('data', piece)\n    })\n\n    return true\n  },\n  function () {\n    if(soFar)\n      this.emit('data', soFar)  \n    this.emit('end')\n  })\n}\n\n//\n// gate \n//\n// while the gate is shut(), buffer incoming. \n// \n// if gate is open() stream like normal.\n//\n// currently, when opened, this will emit all data unless it is shut again\n// if downstream pauses it will still write, i'd like to make it respect pause, \n// but i'll need a test case first.\n\nes.gate = function (shut) {\n\n  var stream = new Stream()\n    , queue = []\n    , ended = false\n\n    shut = (shut === false ? false : true) //default to shut\n\n  stream.writable = true\n  stream.readable = true\n\n  stream.isShut = function () { return shut }\n  stream.shut   = function () { shut = true }\n  stream.open   = function () { shut = false; maybe() }\n  \n  function maybe () {\n    while(queue.length && !shut) {\n      var args = queue.shift()\n      args.unshift('data')\n      stream.emit.apply(stream, args)\n    }\n    stream.emit('drain')\n    if(ended && !shut) \n      stream.emit('end')\n  }\n  \n  stream.write = function () {\n    var args = [].slice.call(arguments)\n  \n    queue.push(args)\n    if (shut) return false //pause up stream pipes  \n\n    maybe()\n  }\n\n  stream.end = function () {\n    ended = true\n    if (!queue.length)\n      stream.emit('end')\n  }\n\n  return stream\n}\n\n//\n// parse\n//\n\nes.parse = function () { \n  return es.through(function (data) {\n    var obj\n    try {\n      if(data) //ignore empty lines\n        obj = JSON.parse(data.toString())\n    } catch (err) {\n      return console.error(err, 'attemping to parse:', data)\n    }\n    this.emit('data', obj)\n  })\n}\n//\n// stringify\n//\n\nes.stringify = function () { \n  return es.mapSync(function (e){\n    return JSON.stringify(e) + '\\n'\n  }) \n}\n\n//\n// replace a string within a stream.\n//\n// warn: just concatenates the string and then does str.split().join(). \n// probably not optimal.\n// for smallish responses, who cares?\n// I need this for shadow-npm so it's only relatively small json files.\n\nes.replace = function (from, to) {\n  return es.connect(es.split(from), es.join(to))\n} \n\n//\n// join chunks with a joiner. just like Array#join\n// also accepts a callback that is passed the chunks appended together\n// this is still supported for legacy reasons.\n// \n\nes.join = function (str) {\n  \n  //legacy api\n  if('function' === typeof str)\n    return es.wait(str)\n\n  var stream = new Stream()\n  var first = true\n  stream.readable = stream.writable = true\n  stream.write = function (data) {\n    if(!first)\n      stream.emit('data', str)\n    first = false\n    stream.emit('data', data)\n    return true\n  }\n  stream.end = function (data) {\n    if(data)\n      this.write(data)\n    this.emit('end')\n  }\n  return stream\n}\n\n\n//\n// wait. callback when 'end' is emitted, with all chunks appended as string.\n//\n\nes.wait = function (callback) {\n  var stream = new Stream()\n  var body = ''\n  stream.readable = true\n  stream.writable = true\n  stream.write = function (data) { body += data }\n  stream.end = function (data) {\n    if(data)\n      body += data\n    if(callback)\n      callback(null, body)\n    stream.emit('data', body)\n    stream.emit('end')\n  }\n  return stream\n}\n\n//\n// helper to make your module into a unix pipe\n// simply add \n// \n// if(!module.parent)\n//  require('event-stream').pipable(asyncFunctionOrStreams)\n// \n// asyncFunctionOrStreams may be one or more Streams or if it is a function, \n// it will be automatically wrapped in es.map\n//\n// then pipe stuff into from the command line!\n// \n// curl registry.npmjs.org/event-stream | node hello-pipeable.js | grep whatever\n//\n// etc!\n//\n// also, start pipeable running as a server!\n//\n// > node hello-pipeable.js --port 44444\n// \n\nvar setup = function (args) {\n  return args.map(function (f) {\n    var x = f()\n      if('function' === typeof x)\n        return es.map(x)\n      return x\n    })\n}\n\nes.pipeable = function () {\n  if(process.title != 'node')\n    return console.error('cannot use es.pipeable in the browser')\n  //(require) inside brackets to fool browserify, because this does not make sense in the browser.\n  var opts = (require)('optimist').argv\n  var args = [].slice.call(arguments)\n  \n  if(opts.h || opts.help) {\n    var name = process.argv[1]\n    console.error([\n      'Usage:',\n      '',\n      'node ' + name + ' [options]',\n      '  --port PORT        turn this stream into a server',\n      '  --host HOST        host of server (localhost is default)',\n      '  --protocol         protocol http|net will require(protocol).createServer(...',\n      '  --help             display this message',\n      '',\n      ' if --port is not set, will stream input from stdin',\n      '',\n      'also, pipe from or to files:',\n      '',\n      ' node '+name+ ' < file    #pipe from file into this stream',\n      ' node '+name+ ' < infile > outfile    #pipe from file into this stream',     \n      '',\n    ].join('\\n'))\n  \n  } else if (!opts.port) {\n    var streams = setup(args)\n    streams.unshift(es.split())\n    //streams.unshift()\n    streams.push(process.stdout)\n    var c = es.connect.apply(null, streams)\n    process.openStdin().pipe(c) //there\n    return c\n\n  } else {\n  \n    opts.host = opts.host || 'localhost'\n    opts.protocol = opts.protocol || 'http'\n    \n    var protocol = (require)(opts.protocol)\n        \n    var server = protocol.createServer(function (instream, outstream) {  \n      var streams = setup(args)\n      streams.unshift(es.split())\n      streams.unshift(instream)\n      streams.push(outstream || instream)\n      es.pipe.apply(null, streams)\n    })\n    \n    server.listen(opts.port, opts.host)\n\n    console.error(process.argv[1] +' is listening for \"' + opts.protocol + '\" on ' + opts.host + ':' + opts.port)  \n  }\n}\n\n//@ sourceURL=/examples/shoe/node_modules/event-stream/index.js"
));

require.define("stream",Function(['require','module','exports','__dirname','__filename','process','global'],"var events = require('events');\nvar util = require('util');\n\nfunction Stream() {\n  events.EventEmitter.call(this);\n}\nutil.inherits(Stream, events.EventEmitter);\nmodule.exports = Stream;\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once, and\n  // only when all sources have ended.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    dest._pipeCount = dest._pipeCount || 0;\n    dest._pipeCount++;\n\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest._pipeCount--;\n\n    // remove the listeners\n    cleanup();\n\n    if (dest._pipeCount > 0) {\n      // waiting for other incoming streams to end.\n      return;\n    }\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest._pipeCount--;\n\n    // remove the listeners\n    cleanup();\n\n    if (dest._pipeCount > 0) {\n      // waiting for other incoming streams to end.\n      return;\n    }\n\n    dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (this.listeners('error').length === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('end', cleanup);\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('end', cleanup);\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n//@ sourceURL=stream"
));

require.define("/examples/shoe/client.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var reconnect = require('../../');\nvar domready = require('domready');\nvar es = require('event-stream');\n\n//****************************************\n//* copy pasted from shoe/example/invert *\n//* but with automatic reconnection!     *\n//****************************************\n\ndomready(function () {\n    var result = document.getElementById('result');\n    \n    var r = reconnect(function (stream) {\n      var s = es.mapSync(function (msg) {\n          result.appendChild(document.createTextNode(msg));\n          return String(Number(msg)^1);\n      });\n      s.pipe(stream).pipe(s);\n\n    }).connect('/invert/aobcagkbcpgapoaotnd')\n\n    document.body.appendChild(r.widget())\n});\n\n//@ sourceURL=/examples/shoe/client.js"
));
require("/examples/shoe/client.js");
})();

